Collection:	Data structures are implemented in java as Collection.
============
Framework   -> large set of classes and interfaces, provides readymade architecture.
Collection is an interface.
Set,List,queue, Map-> Interfaces.

Interface List extends Collection{}
Class Arraylist implements List{}								Class X {}
Class LinkedList implements List,Dequeue{}						Class X {}
Class Vector implements List{}									Class X {}
Class Stack extends Vectot{}

Interface Set extends Collection{}
class HashSet implements Set{}								    Class X {}
Class linkedHashSet implements Set{}							Class X {}
Class TreeSet implements SortedSet{}         Set is unordered whereas TreeSet is ordered i.e sorted because it implements SortedSet  (Interface SortedSet extends Set{}).
					

List:
======
  List can have duplicate values, In case of what if searching element is a duplicate value in list??
				Then it gives the index of first occurance of searching element.

ArrayList:
=========

Before generics, we can store any type of objects in collection i.e. non-generic. Now generics, forces the java programmer to store specific type of objects.
->ArrayList al=new ArrayList();//creating old non-generic arraylist    any type of object can be added.
				
List<Integer> al =new ArrayList<>();  -> correct   al is declared of Type Integer(a Wrapper class).
S.o.p(al)  -> displays elements.   -> correct
Arraylist  -> just a dynamic array.Can have duplicate values and maintains an order(i.e index).
->ArrayList<String> al=new ArrayList<String>();//creating new generic arraylist of particular type

->null values allowed.

add - insertion order, particular index , index starts with 0
	-> ArrayList list = new ArrayList();    Here the type is Object, which includes everything.
	list.add(1);    - works fine.  // [1]   Arraylist internally converts this premitive type to its corresponding wrapper class.(i.e Autoboxing)

	List<String> birds = new ArrayList<>();
	birds.add("hawk"); // [hawk]
	birds.add(1, "robin"); // [hawk, robin]
	birds.add(0, "blue jay"); // [blue jay, hawk, robin]

remove()        - at a particular index or particular object
                arraylist.remove((Integer)4);  - removes object 4
		        arraylist.remove(4);  removes object at index 4
retainAll()     - list1.retainAll(list2) - result is list1 with only common elements of both list1 list2  returns true/false
removeAll()     - reverse of retainAll()
      
set()  - 
 List<String> birds = new ArrayList<>();
 birds.add("hawk"); // [hawk]
 System.out.println(birds.size()); // 1
 birds.set(0, "robin"); // [robin]
 System.out.println(birds.size()); // 1


clear():      clears entire list.
=======

contains():		returns true/false
==========

equals():   to compare 2 lists.two lists are defined to be equal if they contain the same elements in the same order.
========
list1.equals(list2) implies that list1.hashCode()==list2.hashCode() for any two lists, list1 and list2

If object1 and object2 are equal according to their equals() method, they must also have the same hash code.
If object1 and object2 have the same hash code, they do NOT have to be equal too.

In ArrayList insertion, deletion at particular index is slow. As it needs shifting of elements. whereas retrieval is fast using indices.

Arraylist is not synchronized. If you need synchronization use Collections.synchronizedList(..).

To sort given a Arraylist, use Collections.sort(Arraylist). if Arraylist contains null values, NullPointerException is thrown

LinkedList -> LinkedList can be used as both dequeue and list as it implements DeQueue and List interfaces.
==========

LinkedList is implemented as doubly linked list , if an element is removed randomly  no need to shift elements like in the case of ArrayList, it automatically rearranges. So insertion & Deletion are fast in LinkedList.
LinkedList maintains insertion order.
			  
->If multiple threads access a linked list concurrently, and atleast one of the threads modifies the list structurally, it must be synchronized externally.
 (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) 
			
i.e linked list is not synchronized.we have to externally make linked list synchronized using Collections.synchronizedList(..).
			  List list = Collections.synchronizedList(new LinkedList());


listIterator() interface can be used to iterate Lists(all types mainly LinkedList) in both directions.(hasNext(),hasPrevious())
ListIterator can traverse the collection in both directions that is forward as well as backward.

ArrayList has one tuning parameter â€” the initial capacity, which refers to the number of elements the ArrayList can hold before it has to grow. 
LinkedList has no tuning parameters and seven optional operations, one of which is clone. The other six are addFirst, getFirst, removeFirst, addLast, getLast, 
and removeLast. LinkedList also implements the Queue interface

Vector:
=======
The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a  Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created.

Vector uses Enumeration interface to traverse through elements.Iterator can also be used.
Iterator takes over Enumeration. Both are interfaces.
Iterator   :   .hasNext() , .next(), .remove()
Enumeration :   .hasMoreElemnts() ,  .nextElement()   - old.  - fail-safe

Vector is synchronized.i.e thread safe. If a thread-safe implementation is not needed then use ArrayList.

ArrayList vs Vector:
===================
											ArrayList													Vector			
											---------													-------
Synchronization                 :           Not 														synchronized
performance						:			faster because multiple threads can work at a time 			single thread.thread safe.
iterate                         :           Iterator                                                    Enumeration
size                            :           increases the size by 50% when it reaches the limit         doubles the size, when it reaches the limit

ArrayList is better over Vector.

Stack   extends vector class.
=====
The Stack class represents a last-in-first-out (LIFO) stack of objects. It extends class Vector with five operations that allow a vector to be treated as a stack. 
The usual push and pop operations are provided, as well as a method to peek at the top item on the stack, a method to test for whether the stack is empty, 
and a method to search the stack for an item and discover how far it is from the top. 

		Stack<Integer> s=new Stack<Integer>();
		s.push(1);s.push(3);s.push(null);            [null,3,1]

stack will have the initial capacity of 10.
		
		Deque<Integer> stack = new ArrayDeque<Integer>();				All features of stack can be utilized.
		Deque<T> stack = new LinkedList<T>();							This way is also usefull.(Deque can used as stack & queue).

-----------------------------------
Interface Queue extends Collection{}
Class PriorityQueue implements Queue{}							Class X {}
Interface Dequeue extends Queue{}								Class X {} 
Class ArrayDeque implements Dequeue{}							Class X {}		

boolean add(object)
	It is used to insert the specified element into this queue and return true upon success.
boolean offer(object)
	It is used to insert the specified element into this queue.
Object poll()
	It is used to retrieves and removes the head of this queue, or returns null if this queue is empty.
Object remove()
	It is used to retrieves and removes the head of this queue.
Object peek()
	It is used to retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
Object element()
	It is used to retrieves, but does not remove, the head of this queue.

->In case of PriorityQueue, elements are added in natuaral ordering(for premitive types) and needs comparable/comparator for User defined objects.
->In case of ArrayDeque, elements are ordered in FIFO.
---------------------------------

Set:
====
A Set is a Collection that cannot contain duplicate elements. Even if we add duplicate values to set , it won't show any error. It simply adds only one instance.
Set also adds a stronger contract on the behavior of the equals and hashCode operations, allowing Set instances to be compared meaningfully even if their implementation types differ. 
Two Set instances are equal if they contain the same elements.This is to avoid duplicate values.

The Java platform contains three general-purpose Set implementations: HashSet, TreeSet, and LinkedHashSet.

HashSet:
=======

->HashSet, which stores its elements in a hash table, implements hashmap internally, is the best-performing implementation as it uses hashcode() & key.equals() 
 to insert/fetch values.
however it makes no guarantee concerning the order of iteration.There is no particular order in which elements are stored.

Incase of lists, we can retrieve a value at a specific index(list.get(index)). Which is not the case for Set.No indexes.No specific order.

->Hash Set also allows null values.Since set doesn't contain duplicate values, only once null value is added.

****Suppose you have a Collection, c, and you want to create another Collection containing the same elements but with all duplicates eliminated. 
			****Collection<Type> noDups = new HashSet<Type>(c);*****    As hashset store unique values.

The following program prints out all distinct words in its argument list.

		import java.util.*;

		public class FindDups {
		public static void main(String[] args) {
			Set<String> s = new HashSet<String>();
			for (String a : args)
               s.add(a);
               System.out.println(s.size() + " distinct words: " + s);
    }
}

Set tree = new HashSet();
		Test a1 = new Test(22,"jhon");			//there is class named Test.
		Test a2 = new Test(22,"jhon");
		tree.add(a1);
		tree.add(a2);
		System.out.println(tree);			//will add both. because objects are different eventhough there content is same.Same for Linked HashSet too.	

we can specify initial capacity,load factor while intstantiating a hashset.default values new HashSet(16,0.75f);

The capacity is the number of buckets(used to store key and value)in the Hash table. initial capacity is simply the capacity at the time Hash table is created. 

The load factor is a measure of how full the Hash table is allowed to get before its capacity is automatically increased.

Iteration over a HashSet is likely to be more expensive, requiring time proportional to its capacity. 

http://javahungry.blogspot.com/2013/08/how-sets-are-implemented-internally-in.html        ->  link for hashset


		Set<String> stringsref = new HashSet<String>();
		stringsref.add("shiva");
		stringsref.add("aaa");
		Iterator itr = stringsref.iterator();
		while(itr.hasNext()) {
			itr.next();    //if this statement is commented , IllegalStateException is thrown on line itr.remove();
			itr.remove();  // itr.next(); this line must preceed itr.remove() call
		}
		System.out.println(stringsref.size());
 
LinkedHashSet:   -  This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries.
==============
				 -	A subclass of HashSet.

This class provides all of the optional Set operations, and permits null elements. Like HashSet, it provides constant-time performance for the basic operations (add, contains and remove),
assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashSet, due to the added expense of
maintaining the linked list, with one exception: Iteration over a LinkedHashSet requires time proportional to the size of the set, regardless of its capacity. 


-> HashSet, LinkedHashSet uses equals() and hashCode() methods to compare the elements and thus removing the possible duplicate elements.

http://javahungry.blogspot.com/2015/09/how-linkedhashset-works-internally-in-java.html   



TreeSet  -  This class implements SortedSet, a Set interface.Internally TreeMap methods are invoked.
=======
			Red-black tree algorithm is used for sorting.

	A NavigableSet implementation based on a TreeMap. The elements are ordered using their natural ordering (ascending order , alphabetical order), or by a Comparator 
	provided at set creation time, depending on which constructor is used. 
	
	Set<> treeset = new TreeSet<>();   -  Comparable Interface implemented internally. while insert/retrieve/search natuaral ordering is used. this.compareTo(obj) is invoked.
	
						OR
	
	Set<> treeset = new TreeSet<>(new comparatorImpl());    comparatorImpl is a user defined class which should implement Comparator Interface & override compare(arg1,arg2) method.
	
->This implementation provides guaranteed O(log(n)) time cost for the basic operations (add, remove and contains). 
->No null values are allowed. If you try to insert null element into TreeSet, it throws NullPointerException.


->If a collection is given as an input to following

		HashSet 		->    will get a set with unique collection elements with no specific order.
		LinkedHashSet   -> 	  will get a set with unique collection  elements with same insertion order.
		TreeSet			->	  will get a set with unique collection elements with alp/asce order.  it is costly
		

->Collections.sort(listname);   sorting lists. But which sort does it uses to sort? natuaral ordering.
				implements Comparable interface .i.e compareTo()  - used to sort.

public class Test {

	private int age=0;
	private String gender = null;
	Test(int a , String g)
	{
		this.age = a;
		this.gender = g;
	}
}
Set<Test> tree = new TreeSet<Test>();                              
		Test a1 = new Test(22,"jhon");
		Test a2 = new Test(22,"jhon");
		tree.add(a1);//exception
		tree.add(a2);
		
	This is because, Treeset internally stores the elements in a sorted order.

To handle above exception case, Test class should implement comparable interface and override compareTo() method. This is needed because , TreeSet while sorting internally it should know on what field sorting should be done.

public class Test implements Comparable{

	private int age=0;
	private String gender = null;
	Test(int a , String g)
	{
		this.age = a;
		this.gender = g;
	}
	public int compareTo(Test obj)
	{
		if( this.age>obj.age)
			 return 1;
		else
			return -1;
	}
}
				
Red-black tree algorithm :
--------------------------
		A self balancing binarySearch tree. The height of the tree is maintained to be small.
		
	properties:
	node in a tree should be either red or blue in color
	root node should be black
	leaf node should be in black
	childrens of a red node should be in black
	every path from root to leaf should have equal no of black nodes.
	
->when a key is put into map, this node is inserted into tree satisfying binary search tree.then tree rotations are applied to satisfy above properties.

Why do we need TreeSet when we have sortedSet ?
sortedSet is a interface and TreeSet is the class implementing it .As we know one can not create objects of the interface . Interface tells us which methods a sortedSet implementation should provide .TreeSet is such an implementation.
Set tree =  new TreeSet();
-----------------------------------------------
Map Interface:
HashMap , LinkedHashMap, TreeMap  classes

HashMap
   1.  <K,V> pair
   2.  same key with diff value if added , already exiting key corresponding value is overwritten
   3.  null values allowed. both as keys and as values  <null,null>
           so HashMap will always have unique keys including null. Null keys always map to hash 0, thus index 0.
   4.  No guarantee on order of elements, as <K,V> pair is stored into Hashtable.
   5.  Unsynchronized
   6.  iterator object returned by HashMap is Fail-Fast        hashmapobj.iterator()      - this will retrun iterator object
   7.  Both key and value is stored in the bucket as a form of  Entry object .i.e like  (hash,key,value,bucketindex). 
      A bucket is a simple linked list.The bucket is the linked list effectively . Its not a LinkedList as in a java.util.LinkedList -
                                    It's a separate (simpler) implementation just for the map .
   8. HashMap internally works as below or whenever get(key) is called .
             1. Checked whether given Key is null or not  if yes , index is 0
             2. if Key is not null, Object class hashcode() is called for the given key to get hashvalue. Then local hashfucntion is called on hashvalue to get final bucket index.(hashmapobj.get(Key) returns corresponding value)
             3. Based on bucket index corresponding value is retrieved. 
                 Note: multiple keys can have same hash value. implies those are stored as simple linked list in a  bucket. If a bucket has multiple entries, equals() is called to find the right match
             4.   DEFAULT_INITIAL_CAPACITY  = 16 Bucket size.
             5.  public native int hashCode();
             6. int hash = hash(hashvalue);
             7. Map Entry <Key, Value> , Key can be of any type including String , userdefined . So implement equals() method in local for own comparison.
   9. An instance of HashMap has two parameters that affect its performance: initial capacity and load factor
           loadfactor = 0.75 default. how much bucket is allowed before full

Iterate over hashmap:

	Iterator<Entry<String, String>> it = map.entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry<String, String> pair = (Map.Entry<String, String>) it.next();
			System.out.println(pair.getKey() + " = " + pair.getValue());
		}

      for (Map.Entry<String, String> entry : map.entrySet()) {
		    System.out.println(entry.getKey() + " = " + entry.getValue());
		}

	Iterator<String>> it = map.KeySet().iterator();
  
     
 LinkedHashMap:
     1. A hashtable with doubly linked list.
	 2. insertion order is maintained.
	 4. Each entry of bucket will maintain key,value,after,before,next (as it is a doubly linked list)
	 3. O(1) add/remove,..
	 4. fail-fast iterator.


TreeMap :
=======
refer link http://javahungry.blogspot.com/2014/06/how-treemap-works-ten-treemap-java-interview-questions.html

Why do we need TreeMap when we have sortedMap ?
  sortedMap is a interface and TreeMap is the class implementing it .As we know one cannot create objects of the interface . Interface tells us which methods a sortedMap implementation should provide .TreeMap is such an implementation.

Main differences between HashMap and ConcurrentHashMap are :
a. HashMap is not synchronized while ConcurrentHashMap is synchronized and Fail-safe iterator.
b. HashMap can have one null key and any number of null values while ConcurrentHashMap does not allow null keys and null values.

Map interface is not compatible with the Collection interface. Since Map requires key as well as value , for example , if we want to add key-value pair then we will use put(Object key , Object value) .  
------------------------------
Hashtable :  Map<Integer,String> hashtable = new Hashtable<Integer,String>();
    Same as HashMap including internal working, except below few key areas:
     1. Does not  allow null keys and null values.  hashtable.put(null,null) -> NullPointerException
     2. Hashtable is synchronized. HashMap has better performance compared to Hashtable
     3. enumeration is used for traversing elements of hashtable, so hashtable is fail-safe

-----------------------------------------------

1. Collections.sort(list) -  here if elements of list are of type wrapper objects then sorting is done in ascending/chronological order
-> if elements of list are of type user defined objects then , Collections.sort() will throw compile time error because sort doen't 
      know based on which field the objects of the list has to be sorted.
      so to call Collections.sort() on a list , the class of which objects are added must implement Comparable/Comparator interface

2. To get Descending order of given list
   A)  step1. Collections.sort(list);
       step2. Collections.reverse()
   B)  Collections.sort(list, Collections.reverseOrder())

when we call Collections.sort(list) , internally sorting is performed using comparable interface.
when we compare two objects using the comparable interfaces they are actually compared through their ASCII values which is the natural ordering.

1.  Comparable  ->  compareTo(Object obj)
         this,obj are compared
    Comparator  ->  compare(Object obj1,Object obj2)
        obj1 , obj2 are compared

2. In case of Comparable, One has to modify the class whose instances you want to sort while in Comparator one build a class separate from the class whose instances one want to sort . Advantage with 
    Comparator is , implemented as a separate class.so easy to modify and we can write generic sorting technique
3. Comparable  -> java.lang package
    Comparator  ->  java.util 

compareTo(Object  obj)  -  implementation
        public int compareTo(Object a)
	{
		Employee e = (Employee)a;
		System.out.println("compareTo called this "+this+" "+e);
		return this.empid < e.empid ? -1 : this.empid > e.empid ? 1 : 0;
	}

compare(Object obj1 , Object obj2)  - 
    public class CountrySortByIdComparator implements Comparator<Country>{
    
    @Override
    public int compare(Country country1, Country country2) {
        
        return (country1.getCountryId() < country2.getCountryId() ) ? -1: (country1.getCountryId() > country2.getCountryId() ) ? 1:0 ;
    }
    
  }
Anonymous implementation of comparator
      Collections.sort(listOfCountries,new Comparator<Country>() {
            
            @Override
            public int compare(Country o1, Country o2) {
                return o1.getCountryName().compareTo(o2.getCountryName());
            }
        });

- > obj1.compareTo(obj2)   (In case of natural ordering)
 return -ve ->   obj1 should come before obj2
 return +ve ->   obj1 should come after obj2

Example

import java.util.*;
class Employee implements Comparable<Employee> 
{
	int empid;
	private String empName;
	public Employee()
	{
		
	}
	public Employee(int empid , String empName)
	{
		this.empid = empid;
		this.empName = empName;
	}
	public int compareTo(Employee a)
	{
		Employee e = (Employee)a;
		System.out.println("compareTo called this "+this+" "+e);
		return this.empid < e.empid ? -1 : this.empid > e.empid ? 1 : 0;
	}

	public String toString()
	{
		return this.empName;
	}
}
class EmployeecomparatorDemo implements Comparator<Employee> //Collections.sort(a,new EmployeecomparatorDemo()); call
{
	public int compare(Employee obj1  ,  Employee obj2)
	{
		System.out.println("in compare method");
		return obj2.empid < obj1.empid ? -1 : obj2.empid > obj1.empid ? 1 : 0;
	}
}
public class Example {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		try{
		List<Employee> a = new ArrayList<Employee>();
		Employee obj1 = new Employee(111,"shiva1");
		Employee obj2 = new Employee(222,"shiva2");
		Employee obj3 = new Employee(333,"shiva3");
		Employee obj4 = new Employee(444,"shiva4");
		a.add(obj4);
		a.add(obj1);
		a.add(obj3);
		a.add(obj2);
		
		Collections.sort(a);
		Collections.sort(a,new EmployeecomparatorDemo());
		Collections.sort(a, new Employee());//same class implementing comparator too
		Iterator<Employee> itr = a.iterator();
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
		Collections.synchronizedList(a);
		}
		
		catch(Exception e)
		{
			
		}
	}

}
=====================================
Arrays.asList(arrayname) ->			converting array to ArrayList

It takes an array and creates a wrapper that implements List<arrayType>, which makes the original array available as a list.
Nothing is copied, only a single wrapper object is created. Operations on the list wrapper are propagated to the original array.
This means that if you shuffle the list wrapper, the original array is shuffled as well, if you overwrite an element, it gets overwritten in the original array, etc.
Of course, some List operations aren't allowed on the wrapper, like adding or removing elements from the list, you can only read or overwrite the elements.

Note that the list wrapper doesn't extend ArrayList - it's a different kind of object.
ArrayLists have their own, internal array, in which they store their elements, and are able to resize the internal arrays etc.
The wrapper doesn't have its own internal array, it only propagates operations to the array given to it.

new ArrayList<Integer>(Arrays.asList(arrayname))  ->

Here you create new ArrayList, which is a full, independent copy of the original one. Although here you create the wrapper using Arrays.asList as well, 
it is used only during the construction of the new ArrayList and is garbage-collected afterwards. The structure of this new ArrayList is completely independent of the original array.
It contains the same elements (both the original array and this new ArrayList reference the same integers in memory), but it creates a new, internal array, that holds the references. 
So when you shuffle it, add, remove elements etc., the original array is unchanged.