STRINGS: String is Immutable.
=======
+ operator and concat() method on strings -> both used for concatination of strings.but concat() method takes only string as input parameter 
     whereas + operator internally invokes toString()  to convert given input into string if it is not a string.
A String concatenated using + with any other type gives a String.

		String s="1";                           s -> 1
        System.out.println(s); 1
        s+=2;		//s=s+2;
        System.out.println(s);  12			s->12  here initial string remains as it is as string is immutable, instead a new object is created and s points to it.
        s=s.concat("3");
        System.out.println(s);   123			s->123    "		"
        s=s+"4";
        System.out.println(s);	1234			s->1234
        String s1=s.concat("5");				s->1234, s1->12345
        System.out.println(s1);
        System.out.println(s);
		s+='c';			correct
		s+=true;		correct

All string objects are stored in string constant pool.
In string constant pool, If currently creating object already exist, then instead of creating again it simply points to existing one.
Objects created in string constant pool are eligible for garbage collection when the objects are dereferenced.

length() 
charAt(index)  - there is a chance of throwing StringIndexOutOfBoundsException 
		As per the API documentation for charAt, it throws IndexOutOfBoundsException if you pass an invalid value. 
indexOf(char or string)  - returns -1 if specified character is not there.
substring(starting index)  -
substring(starting index, end index)  -   end index is not included in substring.
toLowerCase() and toUpperCase() 
equals() and equalsIgnoreCase() 
startsWith() and endsWith() 
contains() 
replace() 
string1.compareTo(string2)   > 0 , =0 , <0 
compare(string1,string2)
trim() - The trim() method removes whitespace from the begining and end of a String. whitespace consists of spaces along with the \t (tab) and
\n (newline) characters. Other characters, such as \r (carriage return), are also included in what gets trimmed.It leaves the spaces that are in the middle of the string.
tocharArray();

reverse() -  StringBuilder, StringBuffer() has reverse() method , but String donot have.

->These are the six facts on Strings:
1. Literal strings within the same class in the same package represent references to the same String object. 
2. Literal strings within different classes in the same package represent references to the same String object. 
3. Literal strings within different classes in different packages likewise represent references to the same String object. 
4. Strings computed by constant expressions are computed at compile time and then treated as if they were literals. 
5. Strings computed at run time are newly created and therefore are distinct. 
6. The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents. 

String String="some thing"  -> valid
->String class overrides the toString() method that returns just the actual string value unlike toString()(of Object class) which returns classname@hashCode.

String Builder: Mutable
---------------
StringBuilder sb = new StringBuilder("start");
 sb.append("+middle"); // sb = "start+middle"					//here we r using append method not + operator or concat() method.
 StringBuilder same = sb.append("+end"); // "start+middle+end"

 sb -> start+middle+end &  same -> start+middle+end
 StringBuilder changes its own state and returns a reference to itself!
 
StringBuilder sb1 = new StringBuilder();		 size=0; capacity=16(default)
StringBuilder sb2 = new StringBuilder("animal"); size=6; capacity=16;
StringBuilder sb3 = new StringBuilder(10);       size=0; capacity=10;

if size exceeds allocated capacity then java automatically increases the capacity.

 StringBuilder sb = new StringBuilder("animals");
 sb.insert(7, "-"); // sb = animals-
 sb.insert(0, "-"); // sb = -animals-			//observe this carefully
 sb.insert(4, "-"); // sb = -ani-mals			

StringBuilder sb = new StringBuilder("abcdef");
sb.delete(1, 3); // sb = adef
sb.deleteCharAt(5); // throws an exception   StringIndexOutOfBoundsException 

String s = sb.toString();  - correct  because stringbuilder returns stringbuilder object , so we need to convert.

StringBuffer does the same thing as string builder but more slowly because it is thread safe.

String x = "Hello World";
String y = "Hello World";
System.out.println(x == y); // true   because both points to same location
Remember that Strings are immutable and literals are pooled. The JVM created only one literal in memory. x and y both point to the same location in memory.

->String, StringBuilder, and StringBuffer - all are final classes.	
When to use which one :
If a string is going to remain constant throughout the program, then use String class object because a String object is immutable.
If a string can change (example: lots of logic and operations in the construction of the string) and will only be accessed from a single thread, using a StringBuilder is good enough.
If a string can change, and will be accessed from multiple threads, use a StringBuffer because StringBuffer is synchronous so you have thread-safety.	

equals() - Implemented in String class.compare 2 strings content.not references.
equals() - NOT Implemented in StringBuilder class so call to equals() on two StringBuilder instances, it will check reference equality,i.e works like == operator.

->The equals methods of all wrapper classes first check if the two object are of same class or not. If not, they immediately return false. 

** observe carefully the objects on which equals() method is called, because it works only if objects are strings.Otherwise it will compare references like == operator 
you need to implement equals() method.  i.e u need to override equals().(ex: for stringbuilder objects , objects of classes other than String)

If equals() method is not overriden in StringBuilder Class then how we are able to call equals on StringBuilder objects???

StringBuilder sb="shiva"   - wrong     bcz "shiva" is String object 
String s1 = "java";
 StringBuilder s2 = new StringBuilder("java");
 if (s1 == s2)		- wrong.  compile time error. bcz = operator on 2 diff type objects.

String[] strings = { "stringValue" };
 Object[] objects = strings;
 String[] againStrings = (String[]) objects;
 againStrings[0] = new StringBuilder(); // DOES NOT COMPILE
 objects[0] = new StringBuilder(); // careful!         exception is thrown, bcz A StringBuilder object can clearly go in an Object[]. The problem is that we don’t
actually have an Object[]. We have a String[] referred to from an Object[] variable.

Since Java 5, Java has provided a method that prints an array nicely: java.util.Arrays.toString(arrayname) would print [element1, element2, element3,....]

->The array does not allocate space for the String objects. Instead, it allocates space for a reference to where the objects are really stored.

Arrays.sort()  - can sort arrays. In case of strings, make sure all strings are into same case (lower/upper)
Arrays.binarySearch()  -  arrays must be in sorted order, otherwise results are unpredictable.
If target element found in sorted array			-		returns Index of match
If target element not found in sorted array		-		returns Negative value showing one smaller than the negative of index, where a match needs to be inserted to preserve sorted order

Immutable class :
----------------
Immutable class means that once an object is created, we cannot change its content. In Java, all the wrapper classes (like String, Boolean, Byte, Short) are immutable

Following are the requirements:
• Class must be declared as final (So that child classes can’t be created)
• Data members (variables and methods)in the class must be declared as final (So that we can’t change the value of it after object creation)- strong immutable
• A parameterized constructor to initialize
• Getter method for all the variables in it
• No setters(To not have option to change the value of the instance variable) 
  
final class Student                 //this can't be extended as it is declared as final
{ 
    final String name; 
    final int regNo; 
  
    public Student(String name, int regNo) 
    { 
        this.name = name; 
        this.regNo = regNo; 
    } 
    public String getName() 
    { 
        return name; 
    } 
    public int getRegNo() 
    { 
        return regNo; 
    } 
} 
==

=========================================================================================================================================================
static:
======
->static members are called using class name.If you try to call them using instance of the class , still internally it calls using class name.
->You can use an instance of the class to call a static member. The compiler checks for the type of the reference and
	uses that instead of the object.

public class Koala 
{
	public static int count = 0; // static variable
	public static void main(String[] args) { // static method
	System.out.println(count);}
 }
	 Koala k = new Koala();
	 System.out.println(k.count); // k is a Koala  0
	 k = null;
	 System.out.println(k.count); // k is still a Koala	 0

->A static method can directly call another static member(method/var) but must use object to call non-static member(method/var) within the class.
->A non-static method (i.e. an instance method) can only be called on an instance of that class. Whether the caller itself is a static method or not, is immaterial.
private static final ArrayList<String> values = new ArrayList<>();
public static void main(String[] args) 
{
	values.add("changed");
	values.add("added one more");   //true
}
It actually does compile. values is a reference variable. We are allowed to call methods on reference variables. All the compiler can do is check that 
  we don’t try to reassign the final values to point to a different object.
  
->A final variable must be initialized at the time of declaration itself. One exception is that you can initialize them in static block as static block is executed  
  when class is loaded for the first time,or in constructor as the constructor is part of the initialization process, so it is allowed to assign final
  instance variables in it.
  
->a local variable can't be a static? why?		static varibles are bound to class not to particular object whereas local variables are bound to object.

INNER CLASSES, STATIC NESTED CLASSES:
==============================

Refer link : https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html

class within another class is Nested.
Nested classes  -> non static nested classes - Inner classes.
				-> static nested classes.
				
->Here nested class is considered as memeber of outer class like any other data member in class.

->InnerClasses and static nested classes can have private,default,protected,public access specifiers.because these are data members of outer class like any other data 
  members.
->As an inner class(non static nested class) is associated with an outer class instance, it cannot define any static members itself.

->You can instantiate inner class within outer class as Inner iobj=new Inner();
  or using outer class object.i.e
					Outer obj=new Outer();
					Outer.Inner iobj=obj.new Inner();
					
->static nested class is like a static member of a class. We can't instantiate static nested classes within outer class.
     Outerclassname.Inner obj=new OuterClassName.Inner();
	 
Example Prgm:

package com;

class OuterClass
{
	public OuterClass()
	{
		System.out.println("Outerclass default constructor");
		InnerClass innerobj = new InnerClass();
		System.out.println("Inner class data member ="+innerobj.getInner_var());
		System.out.println("Outer static member from inner class = "+innerobj.getOuterstaticvarfromInner());
		
		System.out.println("======================");
		
		staticNestedClass staticnestedclassobj = new staticNestedClass();
		System.out.println("staticNestedClass data members "+staticnestedclassobj.staticnestedvar+" "+staticNestedClass.classname);
		System.out.println("======================");
		
	}
	private int outer_var;
	private static String classname = "Outer";
	public int getVar()
	{
		return outer_var;
	}
	public void setVar(int val)
	{
		outer_var= val;
	}
	 class InnerClass
	{
		private int inner_var;
		private static final String classname = "Inner";  //if final is removed, compilation error

		public InnerClass()
		{
			System.out.println("InnerClass default Constructor");
			inner_var = 20;
		}
		public int getInner_var() {
			return inner_var;
		}

		public void setInner_var(int inner_var) {
			this.inner_var = inner_var;
		}
		public int getOutervarfromInner()
		{
			return getVar();//return outer_var;
		}
		public String getOuterstaticvarfromInner()
		{
			return OuterClass.classname;
		}
	}
	 static class staticNestedClass
	 {
		 public staticNestedClass()
		 {
			 System.out.println("staticNestedClass default constructor ");
			 staticnestedvar = 30;
		 }
		 private int staticnestedvar;
		 private static String classname = "staticNestedClass";
		public int getStaticnestedvar() {
			return staticnestedvar;
		}
		public static String getClassname() {
			return classname;
		}
		 
	 }
}

public class NestedClass {
	
	public static void main(String a[])
	{
		OuterClass outerobj = new OuterClass();
		
		System.out.println("------------from main---------");
		outerobj.setVar(10);
		System.out.println("outer value "+outerobj.getVar());
		
		OuterClass.InnerClass innerobj = outerobj.new InnerClass(); //compilation error if InnerClass is declared as private
		System.out.println("inner value "+innerobj.getInner_var());
		
		System.out.println("===============================");
		OuterClass.staticNestedClass staticnestedobj = new OuterClass.staticNestedClass();
		System.out.println("static nested class data member ="+staticnestedobj.getStaticnestedvar());
	}

}
o/p:
Outerclass default constructor
InnerClass default Constructor
Inner class data member =20
Outer static member from inner class = Outer
======================
staticNestedClass default constructor 
staticNestedClass data members 30 staticNestedClass
======================
------------from main---------
outer value 10
InnerClass default Constructor
inner value 20
===============================
staticNestedClass default constructor 
static nested class data member =30


Anonymous InnerClasses:
========================
We can't create object for abstract classes and interfaces.As these won't have any implementation.But we can indirectly create object for abstract classes and interfaces using anonymous inner classes.

Ex:     
    abstract class Person                                               interface Hai
	{																	{
      abstract void eat();  												void someMethod();
    }  																	}
    class TestAnonymousInner  											class Test
	{																	{
     public static void main(String args[]){  							public static void main(String args[]){
      Person p=new Person(){													  Hai obj=new Hai(){
	  void eat(){System.out.println("nice fruits");}  						void eat(){System.out.println("nice fruits");} 
      };
	  p.eat();  														}
																		;obj.someMethod();
     }  																}}
    }  
		
	
-> Internally a class is created but its name is decided by the compiler which extends the Person class and provides the implementation of the eat() method.
-> An object of Anonymous class is created that is referred by p reference variable of Person type.


-------------------------------
Singleton Class:

public class LazyInitializedSingleton {

    private static LazyInitializedSingleton instance;
    
    private LazyInitializedSingleton(){}
    
    public static LazyInitializedSingleton getInstance(){
        if(instance == null){
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}

public class EagerInitializedSingleton {
    
    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();
    
    //private constructor to avoid client applications to use constructor
    private EagerInitializedSingleton(){}

    public static EagerInitializedSingleton getInstance(){
        return instance;
    }
}

public class StaticBlockSingleton {

    private static StaticBlockSingleton instance;
    
    private StaticBlockSingleton(){}
    
    //static block initialization for exception handling
    static{
        try{
            instance = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException("Exception occured in creating singleton instance");
        }
    }
    
    public static StaticBlockSingleton getInstance(){
        return instance;
    }
}

public class ThreadSafeSingleton {

    private static ThreadSafeSingleton instance;
    
    private ThreadSafeSingleton(){}
    
    public static synchronized ThreadSafeSingleton getInstance(){
        if(instance == null){
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
    
}
  //synchronized block
   public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(instance == null){
        synchronized (ThreadSafeSingleton.class) {
            if(instance == null){
                instance = new ThreadSafeSingleton();
            }
        }
    }
    return instance;
  }

===================
Cloneable Interface:   to copy one object to another not references.  New cloned object will have same data as of old.
 
1.The class must also implement java.lang.Cloneable interface whose object clone we want to create.
2. Every class that override clone() should call super.clone() to obtain the cloned object reference.
3. protected Object clone() throws CloneNotSupportedException
 public Object clone() throws
                   CloneNotSupportedException 
    { 
        return super.clone(); 
    } 
 
Test2 t2 = (Test2)t1.clone();
======================================================================
JDBC: Needed for a java application to interact with data base.
------
 Types of Drivers:
       JDBC-ODBc drivers
	   Native API drivers
	   Network Protocol drivers 
	   Thin driver
java.sql;
Steps to connect to Database:
	Class.forName("oracle.jdbc.driver.OracleDriver");
	DriverManager.getConnection("url,username,passwd");
	PreparedStatement stmt = con.prepareStatement("query");
	ResultSet rs = stmt.executeQuery();
	while (rs.next()) {
	   //each row
        String id = rs.getString(1);
     }
      rs.last();
      int rowCount = rs.getRow();  // these 2 statements using which we can get no of rows in ResultSet.
      System.out.println("Number of Rows=" + rowCount);
	rs.close();
	con.close();
	
Also 	
while(result.next()) {
//each row
    result.getString    ("name");
    result.getInt       ("age");
    result.getBigDecimal("coefficient");

    // etc.
}
	
	
-> A ResultSet object maintains a cursor, which points to its current row of data. ... This kind of result set has the type ResultSet.
 TYPE_FORWARD_ONLY and is referred to as a forward only result set.
 
 Defaultly these already set when you create the Statement or PreparedStatement
 
 Statement statement = connection.createStatement(
    ResultSet.TYPE_FORWARD_ONLY,
    ResultSet.CONCUR_READ_ONLY,
    ResultSet.CLOSE_CURSORS_OVER_COMMIT
   );

PreparedStatement statement = connection.prepareStatement(sql,
    ResultSet.TYPE_FORWARD_ONLY,
    ResultSet.CONCUR_READ_ONLY,
    ResultSet.CLOSE_CURSORS_OVER_COMMIT
   );
 
->There are 3 basic types of ResultSet. As name suggest, this type can only move forward and are non-scrollable.


Difference between createStatement(), PreparedStatement() is, we pass data values to query through wild card (?), using methods setInt(),.. for PreparedStatement. 
execute()          - can be used for any kind of SQL statements. returns TRUE indicates query returned ResultSet, FALSE indicate int value or 0.
executeQuery()     - To retrieve data, retunrns ResultSet()  . SELECT 
executeUpdate()    - To modify/update database. returns no of rows effected / 0 for nothing. INSERT, UPDATE, DELETE, CREATE, ALTER

->What is transaction boundary?
BLOB, CLOB?


==================================
JSON:

public class Car {
 
    private String color;
    private String type;
 
    // standard getters setters
}
Car car = new Car("yellow", "renault");

a)
   ObjectMapper objectMapper = new ObjectMapper();
   ObjectMapper.writeValue(new File("target/car.json"), car);               //{"color":"yellow","type":"renault"}  file content

   Car car = objectMapper.readValue(new File("target/car.json"), Car.class);

b)
   String carAsString = objectMapper.writeValueAsString(car);
   Car car = objectMapper.readValue(carAsString, Car.class);
   
c)
   String json = "{ \"color\" : \"Black\", \"type\" : \"FIAT\" }";
   JsonNode jsonNode = objectMapper.readTree(json);
   String color = jsonNode.get("color").asText();
   // Output: color -> Black
  
d)
  String jsonCarArray = "[{ \"color\" : \"Black\", \"type\" : \"BMW\" }, { \"color\" : \"Red\", \"type\" : \"FIAT\" }]";
  List<Car> listCar = objectMapper.readValue(jsonCarArray, new TypeReference<List<Car>>(){});
  
e) 
  String json = "{ \"color\" : \"Black\", \"type\" : \"BMW\" }";
  Map<String, Object> map = objectMapper.readValue(json, new TypeReference<Map<String,Object>>(){});
===============================================================================================================================
REST WebService:  Representational State Transfer
   
Client <-> Server communication                                                            C-R-U-D - POST-GET-PUT-DELETE

HTTP methods :
GET
POST
PUT
DELETE
CONNECT
HEAD
OPTIONS
TRACE

  HTTP Request -  
      GET/PUT/POST/DELETE
	  URI      /servicename/resource/
	  HEADER
	  HTTP version
	  HTTP request body
  HTTP RESPONSE  -
	  STATUS CODE
      HEADDER
	  HTTP version
	  HTTP response body

HTTP is a stateless protocol. session id is maintained.

@GET
@POST
@PUT
@DELETE
@Path("/servicename/resource")   - @Path("/users/{userid}")
@Produces(MediaType.APPLICATION_XML)
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
@PathParam("userid")

Example: 
   @GET
   @Path("/users/{userid}")
   @Produces(MediaType.APPLICATION_XML)
   public User getUser(@PathParam("userid") int userid){
      return userDao.getUser(userid);
   }
	  
Status code:
  200  - OK
  201  - PUT/POST SUCCESS  (create operations)
  204  - EMPTY BODY (DELETE)
  400  - BAD Request
  401  - FORBIDDEN - access issues 
  404  - resource not found
  500  - INTERNAL SERVER ERROR  (server thrown exceptions)

In Spring  REST web service,   Incomming http request is handled in controller class as below   (a controller class in indicated as @Controller annotation)
@RequestMapping(value= "/resource" , method = RequestMethod.GET)
public List<Student> getAllStudents()
{

}


@ResponseStatus(value= HttpStatus.INTERNAL_SERVER_ERROR)  - setting response status code value

Idempotent -  adding 0 to any value does not result in different value irrespective of no of times add is called.

GET ,PUT, DELETE - idempotent  - state of resource will remains irrespective of no of times operation is called.

POST is not idempotent - every time you invoke POST, new resource will be created.

calling create operation with PUT is, it will not create multiple rows, instead it will update.
===========================================
  org.apache.log4j.Logger
    Logger logger = Logger.getLogger(MainApp.class)
	logger.warn("",..)
	
  org.apache.commons.Logging.LogFactory
    Log log = LogFactory.getLog(MainApp.class)
	log.warn("",..)

-> we will maintain a configuration file in which we will specify log level.
==============================================

Servlet is a program running on web server, which provide dynamic responses for HTTP requests coming from client.
All servelts must implement Javax.Servlet interface.
As HTTP doesn't have any state, to maintain a session between client & server we create session id.
servlet life cycle
        Loading,instantiated, initialized, service the request, destroyed
init , service, destroy callbacks used.
Request Dispatcher:
     forwad the to and from servlet.
	 include(), forward() used for request dispature.
	 forward(): simply forwards request from client to servlet and sends back the response.
	 include(): includes the responses of 2 or more servlets for any received request and sends back cummulative responsse.
	 
web.xml
  <servlet>
    <servlet-name>..........</servelt-name>
	<servelt-class>.........</servelt-class>
  </servlet>
  
  <servlet-mapping>
         <servlet-name>..........</servelt-name>
	     <URL-pattern>.........</URL-pattern>
  </servlet-mapping>	